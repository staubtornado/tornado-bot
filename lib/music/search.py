from difflib import SequenceMatcher
from random import randint, choices
from typing import Union, Callable, Any
from urllib.parse import ParseResult

from discord import Interaction, ApplicationContext, ButtonStyle
from discord.ui import Button, View
from spotipy import SpotifyException

from data.config.settings import SETTINGS
from lib.music.api import get_playlist_track_names, get_track_name, get_album_track_names, get_artist_top_songs
from lib.music.extraction import YTDLSource
from lib.music.song import SongStr, Song
from lib.utils.utils import url_is_valid, split_list


async def guess_type(search: str, ctx, loop) -> YTDLSource:
    source = await YTDLSource.create_source(
        ctx, search=f'{search.replace(":", "")} description: "auto-generated by youtube"', loop=loop)

    match_source: str = source.title
    if " by " in search:
        match_source += f" {source.uploader.replace(' - Topic', '')}"

    if not SequenceMatcher(None, match_source.lower(), search.replace(":", "").lower()).ratio() > 0.5:
        source = await YTDLSource.create_source(ctx, search=search.replace(":", ""), loop=loop)
    return source


async def process(search: str, ctx: Union[ApplicationContext, Any], loop, priority: bool = False) -> \
        Union[str, YTDLSource, None]:
    priority: str = {False: "songs", True: "priority_songs"}[priority]
    search_tracks: Union[list[str], str] = []
    output: str = ""
    responded: bool = False
    url: tuple[bool, ParseResult] = url_is_valid(search)
    if url[0]:
        if url[1].netloc == "open.spotify.com":
            algorithms = {"playlist": get_playlist_track_names, "artist": get_artist_top_songs,
                          "track": get_track_name, "album": get_album_track_names}
            output = "Spotify"

            try:
                result: Union[list[str], str] = await algorithms[url[1].path.split("/")[1]](url[1].path.split("/")[2])
                if isinstance(result, list):
                    search_tracks.extend(result)
                else:
                    search_tracks = result
            except (KeyError, SpotifyException):
                return "❌ **Invalid** Spotify **link**."

        elif "youtube.com" in url[1].netloc:
            url_type: str = await YTDLSource.check_type(search, loop=loop)
            if url_type in ["playlist", "playlist_alt"]:
                search_tracks.extend(await YTDLSource.create_source_playlist(url_type, search, loop=loop))
                output = "YouTube"

    if priority == "priority_songs":
        if len(ctx.voice_state.priority_songs) + len(search_tracks) if isinstance(search_tracks, list) else 1 >= 5:
            return "❌ **Priority Queue** cannot get **larger than 5 songs**."

    max_queue_len: int = SETTINGS["Cogs"]["Music"]["MaxQueueLength"]
    if isinstance(search_tracks, list) and output:
        if len(search_tracks) > max_queue_len:
            class VariableButton(Button):
                def __init__(self, custom_id, callback: Callable, *args, **kwargs):
                    super().__init__(*args, **kwargs)
                    self.custom_id = custom_id
                    self.callback = callback

            class PlaylistParts(View):
                def __init__(self):
                    super().__init__(timeout=15)
                    self.ctx = ctx
                    self.output = output
                    self.value = None

                async def callback(self, interaction: Interaction):
                    self.children: list[Any, Button] = self.children
                    for child in self.children:
                        if child.custom_id == interaction.custom_id:
                            self.value = child.label

                    if self.value == "Help me choose.":
                        await interaction.response.edit_message(
                            content=f"✅ Added **100 songs** from **{output}**", view=None)
                    else:
                        length = str(self.value).split(' - ')
                        await interaction.response.edit_message(
                            content=f"✅ Added **{int(length[1]) + 1 - int(length[0])} "
                                    f"songs** from **{output}**", view=None)
                    self.stop()

            view: PlaylistParts = PlaylistParts()
            for i, part in enumerate(split_list(search_tracks, max_queue_len)):
                if i >= 23:
                    break
                view.add_item(VariableButton(custom_id=str(randint(100000000, 999999999)), callback=view.callback,
                                             label=f"{i * max_queue_len + 1} - {len(part) + (i * max_queue_len)}"))
            view.add_item(VariableButton(custom_id=str(randint(100000000, 999999999)), callback=view.callback,
                                         label=f"Help me choose.", style=ButtonStyle.blurple))
            response = await ctx.respond(
                "⚠️ **Playlist size exceeds** the **queue size**. **What part** do you want **to add**?", view=view)
            await view.wait()

            if view.value is None:
                await response.edit(content="❌ **Timeout**. User did **not respond within 15 seconds**.", view=None)
                return
            if view.value == "Help me choose.":
                search_tracks = choices(search_tracks, k=100)
            else:
                answer: list[str] = str(view.value).split(" - ")
                indices: tuple[int, int, int, int] = int(answer[0]) - 1, int(answer[1]), int(answer[0]), int(answer[1])
                #                                    Backend Start / / / Backend End / / Visual Start / / Backend End
                search_tracks = search_tracks[indices[0]:indices[1]]
            responded = True

        for i, track in enumerate(search_tracks):
            if len(ctx.voice_state.priority_songs) + len(ctx.voice_state.songs) < max_queue_len:
                await ctx.voice_state.__getattribute__(priority).put(SongStr(track, ctx))
                continue
            return f"❌ **Queue reached its limit in size**, therefore **only {i + 1} songs added** from **{output}**."
        return f"✅ Added **{len(search_tracks)} songs** from **{output}**" if not responded else None
    elif output:
        await ctx.voice_state.__getattribute__(priority).put(SongStr(search_tracks, ctx))
        return f"✅ Added **{search_tracks.replace(' by ', '** by **')}**"

    if not url[0]:
        source = await guess_type(search, ctx, loop)
    else:
        source = await YTDLSource.create_source(ctx, search=search, loop=loop)
    await ctx.voice_state.__getattribute__(priority).put(Song(source))
    return f"✅ Added {source}"
